# React

## 理解 React 组件

1. React 组件一般不提供方法，而是某种状态机制
2. React 组件可以理解为一个纯函数
3. 单向数据绑定

### 受控组件

表单元素状态由使用者维护

### 非受控组件

表单元素状态 DOM 自身维护

### 何时创建组件：单一职责原则

1. 每个组件只做一件事
2. 如果组件变得复杂，那么应该拆分成小组件

### 数据状态管理：DRY 原则

1. 能计算得到的状态就不要单独存储
2. 组件尽量无状态，所需数据通过 props 获取

### JSX

本质上不是一种模板，而是一种语法糖

- 优点

1. 声明式创建界面的直观
2. 代码动态创建界面的灵活
3. 无需学习新的模板语言

约定： 自定义组件以大写字母开头

1. React 认为小写的 tag 是原生的 DOM 节点，如 div
2. 大写字母开头为自定义组件
3. JSX 标记可以直接使用属性语法，例如`<menu.item />`

### 生命周期详解

- constructor

1. 用于初始化内部状态，很少使用
2. 唯一可以直接修改 state 的地方

- getDerivedStateFormProps

1. 当 state 需要从 props 初始化时使用
2. 尽量不要使用：维护两者状态一致性会增加复杂度
3. 每次 render 都会调用
4. 典型场景：表单控件获取默认值

- componentDidMount

1. UI 渲染完成后调用
2. 只执行一次
3. 典型场景：获取外部资源

- componentWillUnmount

1. 组件移除时被调用
2. 典型场景：资源释放

- getSnapshotBeforeUpdate

1. 在页面 render 之前调用，state 已更新
2. 典型场景：获取 render 之前的 DOM 状态

- componentDidUpdate

1. 每次 UI 更新时被调用
2. 典型场景： 页面需要更具 props 变化重新获取数据

- shouldComponentUpdate

1. 决定 Virtual DOM 是否要重绘
2. 一般可以由 PureComponent 自动实现
3. 典型场景：性能优化

### 虚拟 DOM 的两个假设

1. 组件的 DOM 结构是相对稳定的
2. 类型相同的兄弟节点可以被唯一标识

- 小结

1. 算法复杂度为 O(n)
2. 虚拟 DOM 如何计算 diff
3. key 属性的作用

### 高阶组件

高阶组件接受组件作为参数，返回新的组件

### 函数子组件

1. 高阶组件和函数子组件都是设计模式
2. 可以实现更多场景的组件复用

### Context API

### Redux

特性：可预测性

state + action = new state

### connect

本质上是一个高阶组件

### Redux 中间件（Middleware）

1. 截获 action
2. 发出 action

- 小结

1. 异步 action 不是特殊 action,而是多个同步 action 的组合使用
2. 中间件在 dispatcher 中截获 action 做特殊处理

### 如何组织 action 和 reducer

把 action 和 reducer 放一起

### 为何需要不可变数据

1. 性能优化
2. 易于调试和跟踪
3. 易于推测

### 基于路由配置进行资源组织

1. 实现业务逻辑的松耦合
2. 易于扩展，重构和维护
3. 路由层面实现 Lazy Load

`<Link>`:普通链接，不会触发浏览器刷新
`<NavLink>`: 类似 Link 但是会添加当前选中状态
`<Prompt>`: 满足条件时提示用户是否离开当前页面
`<Redirect>`: 重定向当前页面，例如登录判断
`<Route>`：路由配置的核心标记，路径匹配时显示对应组件
`<Switch>`：只显示第一个匹配的路由

### 通过 URL 传递参数

1. 如何通过 URL 传递参数：`<Route path="/topic/:id" />`
2. 如何获取参数： this.props.match.params

- 何时需要 URL 参数

页面状态尽量通过 URL 参数定义

1. 每个 React 组件都可以是路由容器
2. ReactRouter 的声明式语法可以方便的定义嵌套路由

### 在页面中使用其他 React 组件

1. 页面也是标准的 node 模块，可使用其他 React 组件
2. 页面会针对性打包，仅包含其引入的组件

## 前端项目的理想架构：

可维护，可扩展，可测试，易开发，易构建

- 易开发

1. 开发工具是否完善
2. 生态圈是否繁荣
3. 社区是否活跃

- 易于扩展

1. 增加新功能是否容易
2. 新功能是否会显著增加系统复杂度

- 易于维护

1. 代码是否容易理解
2. 文档是否健全

- 易于测试

1. 功能的分层是否清晰
2. 副作用少
3. 尽量使用纯函数

- 易于构建

1. 使用通用技术和架构
2. 构建工具的选择

### 拆分复杂度

按领域模型（feature）组织代码，降低耦合度
